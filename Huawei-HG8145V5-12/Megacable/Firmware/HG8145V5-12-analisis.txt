================================================================================
  ANÁLISIS DE FIRMWARE — EchoLife HG8145V5-12 (Megacable)
  Generado: 2026-03-01
================================================================================

DISPOSITIVO OBJETIVO
  Modelo:             EchoLife HG8145V5-12
  Versión Hardware:   43ED.A
  GPON Terminal:      CLASS B+ / PRODUCT ID: 2150087996EGQA063098
  SN:                 4857544347020CB1 (HWTC47020CB1)
  ISP:                Megacable
  Estado ONT:         O5 (Operation state)

================================================================================
CAUSA DEL ERROR "Firmware Upgrade failed" (AlarmID 104058/104509)
================================================================================

  Error original:
    AlarmID:104509 — Software upgrading (Error)
    AlarmID:104058 — Software upgrade failed (Alert)
    "Upload operation fail! FileType:image" (Critical)

  Fuente de los AlarmID (rootfs /etc/wap/alarminfo):
    104058|Upgrade Software Fail|Upgrade software failed.

  Cadena de error (libhw_web_dll.so → libhw_swm_dll.so):
    HW_WEB_SetUploadFail → "Upload operation fail! FileType:%s"
    HW_SWM_UploadFailSendAlarm → envía AlarmID 104058
    HW_SWM_GetAlarmIDByLoadErrCode → mapea código de error → AlarmID

  Causa raíz #1 — Formato binario HWNP incorrecto:
    El empaquetado usaba alineación de 4 bytes entre secciones, pero el
    formato HWNP empaqueta secciones de forma CONTINUA sin padding.
    headLen = 0x128 + num*360 - 4 (datos empiezan 4 bytes antes del fin
    de la tabla de descriptores).

  Causa raíz #2 — ItemCRC en ceros:
    ItemCRC = CRC32(file[storedOffset : storedOffset + dataSize])
    El firmware construido tenía ItemCRC = 0x00000000 en todas las secciones.
    SWM_CheckItemHeadCrc compara el CRC almacenado vs el computado → FALLO.

  Causa raíz #3 — signinfo vs signinfo_v5:
    flash:signinfo → código SWM estándar → SIEMPRE verifica firmas CMS
    file:/var/signinfo → código SWM estándar → SIEMPRE verifica hashes SHA-256
    file:/var/signinfo_v5 → código v5 → permite bypass con header zeroed

    v2.bin usa signinfo_v5 (con magic "whwh" + ceros) → FUNCIONA
    Los demás usan signinfo (con versión activa) → NO se puede bypasear

================================================================================
FORMATO HWNP (Ingeniería inversa completa)
================================================================================

  Offset   Campo          Codificación
  ──────   ─────          ────────────
  0x00     Magic          "HWNP" (4 bytes)
  0x04     PayloadSize    Big-endian uint32 = total_size - 76
  0x08     HeadCRC        Little-endian uint32 = CRC32(file[0x0C:EOF])
  0x0C     HeadLen        Little-endian uint32 = 0x128 + num*360 - 4
  0x10     FileCRC        Little-endian uint32 (para particiones flash)
  0x14     ItemNum        Little-endian uint32 (byte bajo = número de secciones)
  0x18     Version        Little-endian uint32 = 0x01000000
  0x1C     DescSize       Little-endian uint32 = 360
  0x20     Reserved       Little-endian uint32 = 0
  0x24     ProductIDs     ASCII null-terminated, separado por "|" (260 bytes max)
  0x128    Descriptores   360 bytes × num secciones
  headLen  Datos          Empaquetados CONTINUAMENTE (sin padding de alineación)

  Descriptor de sección (360 bytes):
  ──────────────────────────────────
  [0x00] ItemCRC       LE uint32 = CRC32(file[storedOffset : storedOffset+size])
  [0x04] StoredOffset  LE uint32 = headLen + suma_tamaños_previos
  [0x08] DataSize      LE uint32
  [0x0C] Path          ASCII null-terminated (256 bytes)
                       "file:/var/..." = archivo temporal en RAM
                       "flash:..." = partición de flash
  [0x10C] Label        ASCII null-terminated (92 bytes)

  Nota: headLen = desc_region_end - 4, por lo que los datos de la primera
  sección empiezan 4 bytes ANTES del fin de la tabla de descriptores.

================================================================================
SOLUCIÓN APLICADA (3 correcciones)
================================================================================

  1. Empaquetado continuo sin alineación:
     Los datos de cada sección se colocan inmediatamente después de la anterior.
     storedOffset[n] = storedOffset[n-1] + dataSize[n-1]

  2. ItemCRC correcto para cada sección:
     ItemCRC = CRC32(file[storedOffset : storedOffset + dataSize])
     Calculado DESPUÉS de escribir los datos (incluye datos overlapeados).

  3. signinfo → signinfo_v5 (bypass de verificación):
     - Path cambiado de "flash:signinfo" / "file:/var/signinfo" a
       "file:/var/signinfo_v5"
     - Magic "whwh" preservado (bytes 0-3)
     - Header de versión zeroed (bytes 4-59)
     - SWM_ProcSignInfoItem reconoce el formato v5 y permite bypass

  4. Product IDs: 43ED agregado al inicio (para HG8145V5-12)
     Incluye todos los IDs de v2.bin + IDs COMMON originales

  5. UpgradeCheck.xml: 10 checks desactivados (CheckEnable="0")
     Copiado directamente de v2.bin (ya tiene todos desactivados)

  6. HeadCRC: Recalculado CRC32(file[0x0C:EOF])

================================================================================
ARCHIVOS GENERADOS
================================================================================

  HG8145V5-12-COMMON-OK.bin   (16,356 bytes)
    Base: v2.bin (UpgradeCheck + signinfo_v5) + COMMON-OK (dealosgfile.sh)
    Función: Restaurar modo hardware + reboot

  HG8145V5-12-COMMON-PRE.bin  (195,357 bytes)
    Base: v2.bin (UpgradeCheck + signinfo_v5) + COMMON-PRE (hw_ctree.xml + script)
    Función: Reemplazar configuración de región/ISP

  HG8145V5-12-XPON.bin        (17,368 bytes)
    Base: v2.bin (UpgradeCheck + signinfo_v5) + XPON (dealosgfile.sh)
    Función: Conversión GPON↔EPON (modifica hw_boardinfo obj 0x00000001)

  HG8145V5-12-FULL.bin        (50,233,629 bytes / 47.9 MB)
    Base: HG8145V5-.bin (firmware completo con uboot+kernel+rootfs)
    Modificaciones: PIDs + checks + flash:signinfo → file:/var/signinfo_v5
    Función: Firmware completo con uboot, kernel, rootfs, plugins

================================================================================
ROOTFS Y CADENA DE VERIFICACIÓN (Análisis Capstone ARM)
================================================================================

  Rootfs: 39.6 MB SquashFS

  libhw_swm_dll.so (387 KB) — funciones de verificación:
    SWM_CheckPacketHead    — Valida HWNP header + HeadCRC
    SWM_CalHeadCRC         — CRC32(data[0x0C:EOF]), poly 0xEDB88320
    SWM_CheckPdtID         — Compara Product IDs (bypass si CheckEnable="0")
    SWM_CheckItemHeadCrc   — Compara ItemCRC almacenado vs computado
    SWM_CheckAllItemCrc    — Itera todas las secciones, verifica ItemCRC
    SWM_ProcSignInfoItem   — Procesa signinfo: distingue v5 vs estándar
    SWM_CheckSignInfo      — Verifica signinfo estándar (hashes SHA-256 + CMS)
    SWM_UpgradeCheckXmlProc — Procesa flags CheckEnable del XML
    HW_SWM_UploadFailSendAlarm — Envía AlarmID 104058 en caso de fallo

  libhw_web_dll.so — interfaz web:
    HW_WEB_SetUploadFail — "Upload operation fail! FileType:%s"

  /etc/wap/alarminfo — definiciones de alarmas:
    104058|Upgrade Software Fail|Upgrade software failed.

  Strings en .rodata de libhw_swm_dll.so:
    '/var/signinfo_v5' → código v5 (bypass permitido)
    '/var/signinfo'    → código estándar (verifica siempre)
    'signinfo'         → keyword de detección
    "****No need to check CRC****" → skip CRC para secciones file:

================================================================================
EDITOR DE FIRMWARE (tools/firmware-editor/)
================================================================================

  Aplicación Windows (.exe) con interfaz tkinter:
  - Editar Product IDs
  - Toggle de checks en UpgradeCheck.xml
  - Editar shell scripts embebidos
  - Ver hex dump de secciones binarias
  - Al guardar:
    1. Renombra signinfo → signinfo_v5 con magic "whwh" + header zeroed
    2. Recalcula ItemCRC = CRC32(file[storedOff:storedOff+size]) para cada sección
    3. Recalcula HeadCRC = CRC32(file[0x0C:])

  Construir: pip install pyinstaller && pyinstaller firmware_editor.py --onefile
